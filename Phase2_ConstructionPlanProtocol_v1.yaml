# CONSTRUCTION_PLANNING_PROTOCOL.yaml
# Protocol for creating a plan to transform current Illustrator document state to match target image

# === METADATA ===
protocol_name: "Construction Planning Protocol"
version: "1.0"
created: "2026-02-06"
purpose: "Generate actionable plan to reconfigure Illustrator document based on interpretation checkpoint"

# === INPUTS REQUIRED ===
required_inputs:
  - interpretation_checkpoint.yaml  # Approved object inventory from Phase 1
  - illustrator_document_state.json  # Current state export from .ai file
  - stakeholder_image  # Reference image (in context from Phase 1)
  - construction_planning_protocol.yaml  # This file

# === PLANNING SEQUENCE ===
planning_sequence:
  step_1_load_state:
    action: "Load and parse current Illustrator document state file"
    output: "Inventory of existing objects in document"
    extract:
      - "All object names and their types (AREA_*, ICON_*, COMP_*, LABEL_*, PATH_*)"
      - "Layer assignments"
      - "Current positions (if available)"
    
  step_2_compare:
    action: "map identified objects from phase 1 to their corresponding objects in the illustrator document"
    method: ??? Not sure what the best method is. 
    output: "one to one mappings."
    rule: 
    - rule1: SAME_NAME_IMPLIES_IDENTITY:
        forall:
          x: checkpoint_item
          y: illustrator_object
        if:
          - same_name(x, y)
        then:
          - x == y
    - rule2:
      - name: ALIGN_OBJECT_COUNTS_BY_NAME
        
        condition:
          - same_name(checkpoint_item, illustrator_object)
          - count(illustrator_object) != count(checkpoint_item)
        
        action:
          - if: count(illustrator_object) < count(checkpoint_item)
            then:
              - duplicate:
                  target: illustrator_object
                  count: "count(checkpoint_item) - count(illustrator_object)"
          
          - if: count(illustrator_object) > count(checkpoint_item)
            then:
              - remove:
                  target: illustrator_object
                  count: "count(illustrator_object) - count(checkpoint_item)"
                  strategy: "last_created"  # or "first_created", "random", etc.
    
  step_3_categorize_operations:
    action: "Determine operation type for each object change"
    operations:
      ADD: "Object exists in checkpoint but not in current document"
      REMOVE: "Object exists in current document but not in checkpoint"
      RENAME: "Similar object exists but with different name/number"
      MOVE: "Object exists with correct name but wrong position (if positional data available)"
      KEEP: "Object exists in both with correct name"
    output: "Categorized operation lists"
  
  step_4_sequence_operations:
    action: "Order operations to avoid dependency conflicts"
    rules:
      - "REMOVE operations first (clear space)"
      - "ADD parent objects before child objects (e.g., AREA_Furniture before contained ICON)"
      - "ADD operations for standalone objects"
      - "MOVE operations after ADD (requires objects to exist)"
      - "RENAME operations last (cosmetic)"
    output: "Sequenced operation plan"
  
  step_5_specify_parameters:
    action: "Add implementation details to each operation"
    parameters:
      ADD:
        - object_id: "ICON_Chair__001"
        - source_library: "path/to/library/Chair.ai"  # Where to get the symbol/component
        - target_layer: "Icons"  # Which layer to place on
        - position: "relative_to: AREA_Furniture__002, offset: [0, -50]"  # Positioning logic
      
      REMOVE:
        - object_id: "ICON_Staff__005"
        - move_to_unused: true  # Move to unused artboard vs permanent delete
      
      MOVE:
        - object_id: "AREA_Furniture__003"
        - from_position: [100, 200]
        - to_position: [150, 300]
      
      RENAME:
        - from: "ICON_Staff__003"
        - to: "ICON_Staff__001"
    output: "Fully specified operation list"
  
  step_6_validate:
    action: "Check plan for logical consistency"
    checks:
      - "No circular dependencies (A requires B, B requires A)"
      - "All referenced objects exist (parent, adjacent_to references are valid)"
      - "Operation count matches diff (if removing 5 and adding 3, net change = -2)"
      - "No duplicate object IDs in final state"
    output: "Validation report with any warnings"

# === OPERATION SPECIFICATIONS ===

operation_types:
  ADD:
    required_params:
      - object_id: "Target object name (e.g., ICON_Chair__001)"
      - object_type: "AREA | ICON | COMP | LABEL | PATH"
      - target_layer: "Layer name in Illustrator"
    optional_params:
      - source_library: "Path to library file containing symbol/component"
      - position_strategy: "absolute | relative | grid_based | semantic"
      - position_params: "Coordinates or relative positioning data"
      - parent_object: "If contained within another object"
      - styling: "Fill color, stroke, opacity, etc."
    
  REMOVE:
    required_params:
      - object_id: "Object to remove"
    optional_params:
      - move_to_unused: true  # Move to unused artboard instead of delete
      - archive: true  # Keep reference copy
    
  MOVE:
    required_params:
      - object_id: "Object to relocate"
      - target_position: "New position"
    optional_params:
      - from_position: "Current position (for validation)"
      - position_strategy: "How to calculate target position"
    
  RENAME:
    required_params:
      - current_name: "Existing object name"
      - new_name: "Target object name"
    note: "Only changes name/suffix, does not modify visual appearance"
    
  KEEP:
    required_params:
      - object_id: "Object to leave unchanged"
    note: "No action required, listed for completeness"

# === POSITIONING STRATEGIES ===

position_strategies:
  absolute:
    description: "Exact pixel coordinates"
    format: {x: 100, y: 200}
    use_when: "Precise placement known"
  
  relative:
    description: "Position relative to another object"
    format: {relative_to: "AREA_Furniture__002", offset: [0, -50], anchor: "top_center"}
    use_when: "Object should be positioned near/around another object"
  
  grid_based:
    description: "Position in logical grid"
    format: {grid_cell: [2, 3], alignment: "center"}
    use_when: "Objects align to implicit grid structure"
  
  semantic:
    description: "Named positions"
    format: {position: "top_left" | "center" | "bottom_right"}
    use_when: "Grid coordinates unclear, approximate positioning acceptable"
  
  contained:
    description: "Positioned within parent object"
    format: {parent: "AREA_Furniture__001", position: "center" | "top_left" | etc}
    use_when: "Icon/label belongs inside furniture/area"

# === DEPENDENCY RESOLUTION ===

dependency_rules:
  parent_before_child:
    rule: "If object A contains object B, ADD object A before ADD object B"
    example: "ADD AREA_Furniture__001 before ADD ICON_InOutTray__001 (contained within)"
  
  reference_validity:
    rule: "If object A references object B (adjacent_to, relative_to), object B must exist first"
    example: "ADD AREA_Furniture__002 before ADD ICON_Chair__001 (positioned relative to furniture)"
  
  remove_children_first:
    rule: "If removing parent object, remove or relocate children first"
    example: "REMOVE ICON_InOutTray__001 before REMOVE AREA_Furniture__001 (if not moving to unused)"

# === OUTPUT FORMAT ===

construction_plan_output:
  format: |
    # Construction Plan
    
    ## Document State Comparison
    
    **Current state**: [X] objects
    **Target state**: [Y] objects
    **Net change**: [±Z] objects
    
    ### Objects by Operation Type:
    - **ADD**: [N] objects
    - **REMOVE**: [N] objects
    - **MOVE**: [N] objects
    - **RENAME**: [N] objects
    - **KEEP**: [N] objects (no action required)
    
    ---
    
    ## Sequenced Operations Plan
    
    ### Phase A: Remove Operations
    1. REMOVE ICON_Staff__005 → Move to unused artboard
    2. REMOVE AREA_Furniture__010 → Move to unused artboard
    [Continue...]
    
    ### Phase B: Add Parent Objects
    1. ADD AREA_Furniture__002
       - Type: AREA, Subtype: furniture
       - Layer: "Furniture"
       - Position: Grid [1, 1]
       - Source: Library symbol "Table_Standard"
    [Continue...]
    
    ### Phase C: Add Child Objects
    1. ADD ICON_Chair__001
       - Type: ICON, Subtype: chair
       - Layer: "Icons"
       - Position: Relative to AREA_Furniture__002, offset [0, -50], anchor "top_center"
       - Source: Library symbol "Chair_Standard"
    [Continue...]
    
    ### Phase D: Move Operations
    1. MOVE AREA_Furniture__003
       - From: [100, 200]
       - To: [150, 300]
    [Continue...]
    
    ### Phase E: Rename Operations
    1. RENAME ICON_Staff__003 → ICON_Staff__001
    [Continue...]
    
    ---
    
    ## Validation Checks
    
    ✓ No circular dependencies detected
    ✓ All parent objects added before children
    ✓ All position references valid
    ✓ Final object count matches checkpoint: [Y] objects
    ⚠️ [Any warnings]
    
    ---
    
    **Operations total**: [N] operations across [M] phases
    **Estimated complexity**: Low | Medium | High

# === VALIDATION RULES ===

validation_checks:
  dependency_check:
    rule: "Verify no operation depends on an operation that comes later"
    method: "For each ADD with parent/relative_to, confirm referenced object added earlier or exists already"
  
  count_reconciliation:
    rule: "Final object count = current count - removes + adds"
    method: "Calculate: (current_total - REMOVE_count + ADD_count) = checkpoint_total"
  
  duplicate_prevention:
    rule: "No two operations create same object_id"
    method: "Check all ADD operations for unique object_ids"
  
  layer_validity:
    rule: "All target_layer references must exist in document"
    method: "Cross-reference layer names against document_state.json layer list"
  
  position_reference_validity:
    rule: "All relative_to and parent references must be valid object_ids"
    method: "Verify referenced objects exist in current_state OR will be added earlier in sequence"

# === ERROR HANDLING ===

common_issues:
  missing_library_symbols:
    detection: "Source library path does not exist"
    resolution: "Flag operation, suggest using existing similar object or manual creation"
  
  layer_not_found:
    detection: "Target layer does not exist in document"
    resolution: "Either create layer OR default to existing layer (specify which)"
  
  circular_dependency:
    detection: "Object A requires B, B requires A"
    resolution: "Reorder operations OR flag for user clarification"
  
  position_ambiguity:
    detection: "No clear positioning strategy for object"
    resolution: "Default to semantic positioning, flag for user review"

# === ASSUMPTIONS & CONSTRAINTS ===

assumptions:
  - "Illustrator document structure (guides, layers) remains unchanged per fixed_document_rules"
  - "Library symbols/components are available in accessible location"
  - "Document state export is accurate and complete"
  - "Image remains in agent context from Phase 1"

constraints:
  - "No modifications to document guides"
  - "No layer structure changes"
  - "Object overlap is allowed per fixed_document_rules"
  - "Follow Illustrator layout logic per fixed_document_rules"

# === PLANNING PRINCIPLES ===

principles:
  minimalism:
    rule: "Prefer minimal operations - if object can be reused/renamed, prefer that over remove+add"
    example: "If document has ICON_Staff__003 but needs ICON_Staff__001, use RENAME not REMOVE+ADD"
  
  preservation:
    rule: "Move removed objects to unused artboard, don't permanently delete (unless user specifies)"
    rationale: "Allows recovery if plan was incorrect"
  
  explicitness:
    rule: "Every operation must have complete parameters - no implicit assumptions"
    example: "ADD operations must specify layer, position strategy, and source"
  
  verifiability:
    rule: "Plan must be mechanically verifiable before script generation"
    method: "All validation checks must pass before Phase 2 QA"

